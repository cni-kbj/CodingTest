길 찾기 게임
전무로 승진한 라이언은 기분이 너무 좋아 프렌즈를 이끌고 특별 휴가를 가기로 했다.
내친김에 여행 계획까지 구상하던 라이언은 재미있는 게임을 생각해냈고 역시 전무로 승진할만한 인재라고 스스로에게 감탄했다.
라이언이 구상한(그리고 아마도 라이언만 즐거울만한) 게임은, 카카오 프렌즈를 두 팀으로 나누고, 각 팀이 같은 곳을 다른 순서로 방문하도록 해서 먼저 순회를 마친 팀이 승리하는 것이다.
그냥 지도를 주고 게임을 시작하면 재미가 덜해지므로, 라이언은 방문할 곳의 2차원 좌표 값을 구하고 각 장소를 이진트리의 노드가 되도록 구성한 후, 순회 방법을 힌트로 주어 각 팀이 스스로 경로를 찾도록 할 계획이다.
라이언은 아래와 같은 특별한 규칙으로 트리 노드들을 구성한다.
트리를 구성하는 모든 노드의 x, y 좌표 값은 정수이다.
모든 노드는 서로 다른 x값을 가진다.
같은 레벨(level)에 있는 노드는 같은 y 좌표를 가진다.
자식 노드의 y 값은 항상 부모 노드보다 작다.
임의의 노드 V의 왼쪽 서브 트리(left subtree)에 있는 모든 노드의 x값은 V의 x값보다 작다.
임의의 노드 V의 오른쪽 서브 트리(right subtree)에 있는 모든 노드의 x값은 V의 x값보다 크다.
아래 예시를 확인해보자.
라이언의 규칙에 맞게 이진트리의 노드만 좌표 평면에 그리면 다음과 같다. (이진트리의 각 노드에는 1부터 N까지 순서대로 번호가 붙어있다.)
![tree_3.png](https://grepp-programmers.s3.amazonaws.com/files/production/dbb58728bd/a5371669-54d4-42a1-9e5e-7466f2d7b683.jpg)
이제, 노드를 잇는 간선(edge)을 모두 그리면 아래와 같은 모양이 된다.
![tree_4.png](https://grepp-programmers.s3.amazonaws.com/files/production/6bd8f6496a/50e1df20-5cb7-4846-86d6-2a2f1e70c5da.jpg)
위 이진트리에서 전위 순회(preorder), 후위 순회(postorder)를 한 결과는 다음과 같고, 이것은 각 팀이 방문해야 할 순서를 의미한다.
전위 순회 : 7, 4, 6, 9, 1, 8, 5, 2, 3
후위 순회 : 9, 6, 5, 8, 1, 4, 3, 2, 7
다행히 두 팀 모두 머리를 모아 분석한 끝에 라이언의 의도를 간신히 알아차렸다.

그러나 여전히 문제는 남아있다. 노드의 수가 예시처럼 적다면 쉽게 해결할 수 있겠지만, 예상대로 라이언은 그렇게 할 생각이 전혀 없었다.
이제 당신이 나설 때가 되었다.
곤경에 빠진 카카오 프렌즈를 위해 이진트리를 구성하는 노드들의 좌표가 담긴 배열 nodeinfo가 매개변수로 주어질 때,
노드들로 구성된 이진트리를 전위 순회, 후위 순회한 결과를 2차원 배열에 순서대로 담아 return 하도록 solution 함수를 완성하자.
제한사항
nodeinfo는 이진트리를 구성하는 각 노드의 좌표가 1번 노드부터 순서대로 들어있는 2차원 배열이다.
nodeinfo의 길이는 1 이상 10,000 이하이다.
nodeinfo[i] 는 i + 1번 노드의 좌표이며, [x축 좌표, y축 좌표] 순으로 들어있다.
모든 노드의 좌표 값은 0 이상 100,000 이하인 정수이다.
트리의 깊이가 1,000 이하인 경우만 입력으로 주어진다.
모든 노드의 좌표는 문제에 주어진 규칙을 따르며, 잘못된 노드 위치가 주어지는 경우는 없다.

입출력 예
nodeinfo	                                                
[[5,3],[11,5],[13,3],[3,5],[6,1],[1,3],[8,6],[7,2],[2,2]]	
result
[[7,4,6,9,1,8,5,2,3],[9,6,5,8,1,4,3,2,7]]
입출력 예 설명
입출력 예 #1
문제에 주어진 예시와 같다.

--
문제 해결 접근 방법
이 문제는 주어진 nodeinfo 배열을 기반으로 이진트리를 생성한 뒤, 두 가지 순회 방법인 전위 순회(Pre-order)와 후위 순회(Post-order)를 적용하여 트리의 노드를 순차적으로 방문한 순서를 반환하는 문제입니다.
문제를 해결하기 위한 주요 접근 방식:
노드 정보 파싱 및 트리 구성:
주어진 nodeinfo 배열에서 각 노드는 [x, y] 좌표를 가지고 있으며, 좌표와 함께 노드 번호를 추가해야 합니다.
트리를 구성할 때, y 값을 기준으로 내림차순으로 먼저 정렬합니다. 같은 y 값을 가진 노드들이 있을 경우, x 값을 기준으로 오름차순으로 정렬합니다.
트리의 각 노드는 왼쪽 서브트리나 오른쪽 서브트리를 가질 수 있습니다. 이진트리의 규칙을 따라 왼쪽 자식 노드의 x 값은 부모 노드의 x 값보다 작고, 오른쪽 자식 노드의 x 값은 부모 노드의 x 값보다 큽니다.
트리의 순회 방법:
전위 순회 (Pre-order): 루트 -> 왼쪽 서브트리 -> 오른쪽 서브트리 순으로 방문합니다.
후위 순회 (Post-order): 왼쪽 서브트리 -> 오른쪽 서브트리 -> 루트 순으로 방문합니다.
각 순회 방법은 재귀적으로 자식 노드를 순차적으로 방문하면서 결과를 반환합니다.
재귀 깊이 처리:
트리가 매우 깊어질 수 있으므로, 파이썬의 기본 재귀 깊이 제한을 초과하지 않도록 setrecursionlimit을 사용하여 재귀 깊이를 조정합니다. 이 문제에서는 트리의 깊이가 1000 이하로 제한이 있지만, 깊은 트리에서 발생할 수 있는 RecursionError를 방지하기 위해 재귀 깊이를 10000으로 늘렸습니다.

--
설명
코드 동작 설명
노드 번호 추가:
각 노드에는 좌표 [x, y] 외에 **번호**를 부여해야 합니다. 이를 위해 각 노드에 info.append(idx + 1)을 사용하여 번호를 추가합니다.
정렬:
nodeinfo.sort(key=lambda x: (-x[1], x[0])): 트리의 루트 노드를 가장 먼저 정하기 위해 y 값을 기준으로 내림차순으로 정렬하고, 같은 y 값에서는 x 값을 기준으로 오름차순으로 정렬합니다.
트리 구성:
첫 번째 노드를 루트로 설정하고, 나머지 노드는 add_node 함수를 사용하여 트리에 추가합니다.
add_node 함수는 트리의 규칙에 맞게 왼쪽 자식은 부모보다 x 값이 작은 노드, 오른쪽 자식은 부모보다 x 값이 큰 노드를 추가합니다.
전위 순회 (Pre-order):
루트부터 시작하여 왼쪽 서브트리, 오른쪽 서브트리를 재귀적으로 방문하면서 노드를 순서대로 반환합니다.
후위 순회 (Post-order):
왼쪽 서브트리와 오른쪽 서브트리를 먼저 방문하고, 마지막에 루트를 방문하여 노드를 순서대로 반환합니다.
재귀 깊이 설정:
트리의 깊이가 매우 깊을 수 있기 때문에 **setrecursionlimit(10000)**을 설정하여 재귀 호출이 너무 깊어져도 **RecursionError**가 발생하지 않도록 합니다. 이 설정으로 깊은 트리도 정상적으로 처리할 수 있습니다.
문제 해결 전략
트리 깊이가 깊을 수 있음: 트리가 매우 깊어질 수 있기 때문에 파이썬의 기본 재귀 깊이를 조정하는 것이 중요합니다.
트리의 규칙에 맞게 노드를 배치: 각 노드는 x 값을 기준으로 왼쪽과 오른쪽 자식이 정해지며, y 값에 따라 레벨이 결정됩니다. 이 규칙을 유지하면서 트리 구조를 구축해야 합니다.
효율적인 순회: 전위 순회와 후위 순회는 재귀를 사용하여 간단하게 구현하되, 깊은 트리에서도 문제없이 실행되도록 setrecursionlimit을 활용합니다.



**핵심 아이디어:**

코드는 2차원 좌표 (x, y)로 주어진 노드 정보를 이용하여 이진 검색 트리(BST)를 구성하고, 구성된 트리에 대해 전위 순회(preorder traversal)와 후위 순회(postorder traversal)를 수행합니다.  트리 구성 시 y 좌표가 큰 순서대로, y 좌표가 같다면 x 좌표가 작은 순서대로 노드를 정렬하여 트리에 삽입합니다.

**시각화 설명:**

각 테스트 케이스별로 노드 추가 순서, 이진 트리 구성 형태, 전위 순회 경로, 후위 순회 경로를 그림과 함께 설명하겠습니다.  각 그림에서 노드 번호는 노드 정보 리스트에서의 원래 인덱스 + 1로 표현됩니다.

**테스트 케이스 1: `nodeinfo = [[5,3],[11,5],[13,3],[3,5],[6,1],[1,3],[8,6],[7,2],[2,2]]`**

1.  **노드 정렬:**

    *   입력 노드 정보에 인덱스 추가:  `[[5, 3, 1], [11, 5, 2], [13, 3, 3], [3, 5, 4], [6, 1, 5], [1, 3, 6], [8, 6, 7], [7, 2, 8], [2, 2, 9]]`
    *   정렬 후: `[[8, 6, 7], [3, 5, 4], [11, 5, 2], [5, 3, 1], [13, 3, 3], [1, 3, 6], [7, 2, 8], [2, 2, 9], [6, 1, 5]]`

2.  **이진 트리 구성:**

    *   **루트 노드:**  (8, 6) - 노드 번호 7

    ```
            7 (8,6)
    ```

    *   **(3, 5) - 노드 번호 4 삽입:** x 좌표가 8보다 작으므로 왼쪽 자식으로 삽입

    ```
            7 (8,6)
           /
          4 (3,5)
    ```

    *   **(11, 5) - 노드 번호 2 삽입:** x 좌표가 8보다 크므로 오른쪽 자식으로 삽입

    ```
            7 (8,6)
           /   \
          4 (3,5) 2 (11,5)
    ```

    *   **(5, 3) - 노드 번호 1 삽입:** 루트(7)의 왼쪽, (4)의 오른쪽

    ```
            7 (8,6)
           /   \
          4 (3,5) 2 (11,5)
           \
            1 (5,3)
    ```

    *   **(13, 3) - 노드 번호 3 삽입:** 루트(7)의 오른쪽, (2)의 오른쪽

    ```
            7 (8,6)
           /   \
          4 (3,5) 2 (11,5)
           \       \
            1 (5,3)  3 (13,3)
    ```

    *   **(1, 3) - 노드 번호 6 삽입:** 루트(7)의 왼쪽, (4)의 왼쪽

    ```
            7 (8,6)
           /   \
          4 (3,5) 2 (11,5)
         / \       \
        6 (1,3)1 (5,3)  3 (13,3)
    ```

    *   **(7, 2) - 노드 번호 8 삽입:** 루트(7)의 왼쪽, (4)의 오른쪽, (1)의 왼쪽

    ```
            7 (8,6)
           /   \
          4 (3,5) 2 (11,5)
         / \       \
        6 (1,3)1 (5,3)  3 (13,3)
               /
              8 (7,2)
    ```

    *   **(2, 2) - 노드 번호 9 삽입:** 루트(7)의 왼쪽, (4)의 왼쪽, (6)의 오른쪽

    ```
            7 (8,6)
           /   \
          4 (3,5) 2 (11,5)
         / \       \
        6 (1,3)1 (5,3)  3 (13,3)
       /               /
      9 (2,2)         8 (7,2)
    ```

    *   **(6, 1) - 노드 번호 5 삽입:** 루트(7)의 왼쪽, (4)의 오른쪽, (1)의 오른쪽

    ```
            7 (8,6)
           /   \
          4 (3,5) 2 (11,5)
         / \       \
        6 (1,3)1 (5,3)  3 (13,3)
       /       /       /
      9 (2,2) 8 (7,2)  5 (6,1)
    ```

3.  **순회 결과:**

    *   **전위 순회:** 7 -> 4 -> 6 -> 9 -> 1 -> 8 -> 5 -> 2 -> 3  => `[7, 4, 6, 9, 1, 8, 5, 2, 3]`
    *   **후위 순회:** 9 -> 6 -> 8 -> 5 -> 1 -> 4 -> 3 -> 2 -> 7  => `[9, 6, 8, 5, 1, 4, 3, 2, 7]`

4.  **결과:** `[[7, 4, 6, 9, 1, 8, 5, 2, 3], [9, 6, 5, 8, 1, 4, 3, 2, 7]]`

**테스트 케이스 2: `nodeinfo = [[5, 3], [3, 4], [7, 2], [2, 5], [6, 1]]`**

1.  **노드 정렬:**

    *   입력 노드 정보에 인덱스 추가: `[[5, 3, 1], [3, 4, 2], [7, 2, 3], [2, 5, 4], [6, 1, 5]]`
    *   정렬 후: `[[2, 5, 4], [3, 4, 2], [5, 3, 1], [7, 2, 3], [6, 1, 5]]`

2.  **이진 트리 구성:**

    *   **루트 노드:** (2, 5) - 노드 번호 4

    ```
            4 (2,5)
    ```

    *   **(3, 4) - 노드 번호 2 삽입:** x 좌표가 2보다 크므로 오른쪽 자식으로 삽입

    ```
            4 (2,5)
             \
              2 (3,4)
    ```

    *   **(5, 3) - 노드 번호 1 삽입:** 루트(4)의 오른쪽, (2)의 오른쪽

    ```
            4 (2,5)
             \
              2 (3,4)
               \
                1 (5,3)
    ```

    *   **(7, 2) - 노드 번호 3 삽입:** 루트(4)의 오른쪽, (2)의 오른쪽, (1)의 오른쪽

    ```
            4 (2,5)
             \
              2 (3,4)
               \
                1 (5,3)
                 \
                  3 (7,2)
    ```

    *   **(6, 1) - 노드 번호 5 삽입:** 루트(4)의 오른쪽, (2)의 오른쪽, (1)의 오른쪽, (3)의 왼쪽

    ```
            4 (2,5)
             \
              2 (3,4)
               \
                1 (5,3)
                 \
                  3 (7,2)
                 /
                5 (6,1)
    ```

3.  **순회 결과:**

    *   **전위 순회:** 4 -> 2 -> 1 -> 3 -> 5  => `[4, 2, 1, 3, 5]`
    *   **후위 순회:** 5 -> 3 -> 1 -> 2 -> 4  => `[5, 3, 1, 2, 4]`

4.  **결과:** `[[4, 2, 1, 3, 5], [5, 3, 1, 2, 4]]`

**요약:**

이러한 방식으로, 입력 노드 정보를 정렬하고 이진 검색 트리를 구성한 후, 전위 순회와 후위 순회를 수행하여 원하는 결과를 얻을 수 있습니다. 각 단계별로 시각화된 트리의 형태를 이해하면 코드의 동작 방식을 더욱 명확하게 파악할 수 있습니다.
